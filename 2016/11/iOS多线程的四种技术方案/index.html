<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://natoto.github.io">
  <title>共田三皮君</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="layout: posttitle: “iOS 多线程的四种技术方案”date: 2016-11-22description: “ios多线程”tag: 多线程

#iOS 多线程的四种技术方案

pthread 实现多线程操作
代码实现：1234567891011121314151617181920void * run(void *param)&amp;#123;    for (NSInteger">
<meta property="og:type" content="article">
<meta property="og:title" content="共田三皮君">
<meta property="og:url" content="http://natoto.github.io/2016/11/iOS多线程的四种技术方案/index.html">
<meta property="og:site_name" content="共田三皮君">
<meta property="og:description" content="layout: posttitle: “iOS 多线程的四种技术方案”date: 2016-11-22description: “ios多线程”tag: 多线程

#iOS 多线程的四种技术方案

pthread 实现多线程操作
代码实现：1234567891011121314151617181920void * run(void *param)&amp;#123;    for (NSInteger">
<meta property="og:image" content="https://github.com/Natoto/ios-Multithread/blob/master/images/fourmethod.png?raw=true">
<meta property="og:image" content="https://github.com/Natoto/ios-Multithread/blob/master/images/gcdqueue.png?raw=true">
<meta property="og:image" content="https://github.com/Natoto/ios-Multithread/blob/master/images/gcdmethod.png?raw=true">
<meta property="og:image" content="https://github.com/Natoto/ios-Multithread/blob/master/images/dispatchafter.png?raw=true">
<meta property="og:image" content="https://github.com/Natoto/ios-Multithread/blob/master/images/dispatchafter2.png?raw=true">
<meta property="og:image" content="http://mp.weixin.qq.com/mp/qrcode?scene=10000004&size=102&__biz=MzA3ODQyNDM0Mg==">
<meta property="og:updated_time" content="2016-11-22T08:17:19.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="共田三皮君">
<meta name="twitter:description" content="layout: posttitle: “iOS 多线程的四种技术方案”date: 2016-11-22description: “ios多线程”tag: 多线程

#iOS 多线程的四种技术方案

pthread 实现多线程操作
代码实现：1234567891011121314151617181920void * run(void *param)&amp;#123;    for (NSInteger">
<meta name="twitter:image" content="https://github.com/Natoto/ios-Multithread/blob/master/images/fourmethod.png?raw=true">
  
    <link rel="alternative" href="/atom.xml" title="共田三皮君" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/smallIcon.jpg">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/images/avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">nonato</a></h1>
		</hgroup>

		
		<p class="header-subtitle">YY.INC混泥土瞬间移动工程师</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/Natoto" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/huangbo0913?is_hot=1" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">nonato</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="/images/avatar.jpg" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">nonato</h1>
			</hgroup>
			
			<p class="header-subtitle">YY.INC混泥土瞬间移动工程师</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/">随笔</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Natoto" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/huangbo0913?is_hot=1" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        <article id="post-iOS多线程的四种技术方案" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>layout: post<br>title: “iOS 多线程的四种技术方案”<br>date: 2016-11-22<br>description: “ios多线程”<br>tag: 多线程</p>
<hr>
<p>#iOS 多线程的四种技术方案</p>
<p><img src="https://github.com/Natoto/ios-Multithread/blob/master/images/fourmethod.png?raw=true" alt="image"></p>
<p>pthread 实现多线程操作</p>
<p>代码实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> * run(<span class="keyword">void</span> *param)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span> (NSInteger i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</div><div class="line">        NSLog(@<span class="string">"---buttonclick---%zd---%@"</span>, i, [NSThread currentThread]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (IBAction)clickButton:(id)sender &#123;</div><div class="line">    <span class="comment">// 定义一个线程</span></div><div class="line">    pthread_t thread;</div><div class="line">    <span class="comment">// 创建一个线程  (参1)pthread_t *restrict:创建线程的指针，(参2)const pthread_attr_t *restrict:线程属性  (参3)void *(*)(void *):线程执行的函数的指针，(参4)void *restrict:null</span></div><div class="line">    pthread_create(&amp;thread, NULL, run, NULL);</div><div class="line">    <span class="comment">// 何时回收线程不需要你考虑</span></div><div class="line">    pthread_t thread2;</div><div class="line">    pthread_create(&amp;thread2, NULL, run, NULL);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="NSThread实现多线程"><a href="#NSThread实现多线程" class="headerlink" title="NSThread实现多线程"></a>NSThread实现多线程</h3><p>一个 NSThread 对象就代表一条线程</p>
<p>######创建线程的多种方式</p>
<ol>
<li>第一种方式：先创建再启动线程<br>// 创建线程<br>NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:@”jack”];<br>// 线程启动了，事情做完了才会死， 一个NSThread对象就代表一条线程<br>[thread start];</li>
<li>第二种：直接创建并启动线程<br>// 直接创建并启动线程<br>[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@”jack”];</li>
<li>第三种：<br>// 直接创建并启动线程<br>[self performSelectorInBackground:@selector(run:) withObject:@”jack”];<br>// 使线程进入阻塞状态<br>[NSThread sleepForTimeInterval:2.0];</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#pragma mark - 执行run方法</div><div class="line">- (void)run:(NSString *)param</div><div class="line">&#123;</div><div class="line">    // 当前线程是否是主线程</div><div class="line">    for (NSInteger i = 0; i &lt; 100; i++) &#123;</div><div class="line">        NSLog(@"---%@---%zd---%d", [NSThread currentThread], i,  [NSThread isMainThread]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法2和方法3的优点:快捷<br>方法1的优点:可以轻松拿到线程<br>线程间通信<br>线程间通信的体现<br>1个线程传递数据给另1个线程<br>在1个线程中执行完特定任务后，转到另1个线程继续执行任务<br>线程间通信的常用方法：小程序图片下载</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">-(UIImageView *)imageView</div><div class="line">&#123;</div><div class="line">    if (!_imageView) &#123;</div><div class="line">        _imageView = [UIImageView new];</div><div class="line">        _imageView.frame = CGRectMake(0, 0, 300, 300);</div><div class="line">        _imageView.center = self.view.center;</div><div class="line">        [self.view addSubview:_imageView];</div><div class="line">    &#125;</div><div class="line">    return _imageView;</div><div class="line">&#125;</div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //监听线程结束的通知</div><div class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handle_threadexit:) name:NSThreadWillExitNotification object:nil];</div><div class="line">    </div><div class="line">    // Do any additional setup after loading the view.</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)didReceiveMemoryWarning &#123;</div><div class="line">    [super didReceiveMemoryWarning];</div><div class="line">    // Dispose of any resources that can be recreated.</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    //第一种方式：先创建再启动线程</div><div class="line">    // 创建线程</div><div class="line">    NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:@"booob"];</div><div class="line">    </div><div class="line">    // 线程启动了，事情做完了才会死， 一个NSThread对象就代表一条线程</div><div class="line">    [thread start];</div><div class="line">    </div><div class="line">    //第二种：直接创建并启动线程</div><div class="line">    // 直接创建并启动线程</div><div class="line">    [NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@"wang"];</div><div class="line">    </div><div class="line">    </div><div class="line">    //第三种：</div><div class="line">    // 直接创建并启动线程</div><div class="line">    [self performSelectorInBackground:@selector(run:) withObject:@"wang000"];</div><div class="line">    // 使线程进入阻塞状态</div><div class="line">    [NSThread sleepForTimeInterval:2.0];</div><div class="line">    </div><div class="line">    </div><div class="line">    //例子</div><div class="line">    // 获取图片的url</div><div class="line">    NSURL *url = [NSURL URLWithString:@"https://pages.github.com/images/slideshow/yeoman.png"];</div><div class="line">    // 另开1条线程 object用于数据的传递</div><div class="line">    NSThread *thread3 = [[NSThread alloc] initWithTarget:self selector:@selector(downLoadWithURL:) object:url];</div><div class="line">    thread3.name = @"downloadimage...";</div><div class="line">    // 由于下面下载图片的耗时太长，应开启线程来完成</div><div class="line">    [thread3 start];</div><div class="line"></div><div class="line">&#125;</div><div class="line">#pragma mark - 执行run方法</div><div class="line">- (void)run:(NSString *)param</div><div class="line">&#123;</div><div class="line">    // 当前线程是否是主线程</div><div class="line">    for (NSInteger i = 0; i &lt; 10; i++) &#123;</div><div class="line">        NSLog(@"---%@---%zd---%d", [NSThread currentThread], i,  [NSThread isMainThread]);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">//线程直接的交互</div><div class="line">// 下载图片</div><div class="line">- (void)downLoadWithURL:(NSURL *)url</div><div class="line">&#123;</div><div class="line">    NSLog(@"%s ,%s %@",__FILE__,__FUNCTION__, [NSThread currentThread]);</div><div class="line">    // 下载图片</div><div class="line">    NSData *data = [NSData dataWithContentsOfURL:url];</div><div class="line">    // 生成图片</div><div class="line">    UIImage *image = [UIImage imageWithData:data];</div><div class="line">    // 返回主线程显示图片</div><div class="line">    [self.imageView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:YES];</div><div class="line">&#125;</div><div class="line"></div><div class="line">//处理线程结束事件</div><div class="line">-(void)handle_threadexit:(NSNotification *)notify</div><div class="line">&#123;</div><div class="line">    NSThread  * thread = (NSThread *)notify.object;</div><div class="line">    NSLog(@"+++++++++++++++ 线程 %@ 结束 ++++++++++++",thread.name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>TIPS: 拓展，线程结束的通知<br>以上下载图片方式使用线程已经过时了，开发中我们操作线程大多都使用 GCD 和 NSOperation 来实现多线程操作。</p>
<p>——————————————————————————————————————————</p>
<h3 id="GCD-是如何实现多线程的"><a href="#GCD-是如何实现多线程的" class="headerlink" title="GCD 是如何实现多线程的"></a>GCD 是如何实现多线程的</h3><ul>
<li>GCD 实现多线程</li>
<li>GCD 简介</li>
<li><p>GCD 全称是<code>Grand Central Dispatch</code>，可译为“超级厉害的中枢调度器”，GCD 是苹果公司为多核的并行运算提出的解决方案， GCD会自动利用更多的 CPU 内核（比如双核、四核）来开启线程执行任务，GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程），不需要我们程序员手动管理内存。</p>
</li>
<li><p>任务和队列</p>
</li>
<li>任务：在同步函数和异步函数中执行</li>
<li>队列：用来存放任务（并发 串行）</li>
</ul>
<p><img src="https://github.com/Natoto/ios-Multithread/blob/master/images/gcdqueue.png?raw=true" alt="images"></p>
<p>   GCD会自动将队列中的任务取出，放到对应的线程，任务的取出遵循<code>FIFO</code>，即先入先出队列，<code>First Input First Output</code> 的缩写。<br>   先进入的任务先完成并结束，再执行后面的任务。<br>同步函数和异步函数，并发队列和串行队列<br>用同步的方式执行任务：在当前线程中可立即执行任务，不具备开启线程的能力<br>用异步的方式执行任务：在当前线程结束时执行任务，具备开启新的线程的能力</p>
<ul>
<li><p>并发队列：允许多个任务同时执行</p>
</li>
<li><p>串行队列：一个任务执行完毕后，再执行下一个任务</p>
</li>
</ul>
<p>创建并发/串行队列代码：</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">      dispatch_queue_t queue = dispatch_get_main_queue();</div><div class="line">    // 创建串行队列  serial 串行  concurrent并发</div><div class="line">    queueSerial = dispatch_queue_create("searial.whenbar.com", DISPATCH_QUEUE_SERIAL);</div><div class="line">    </div><div class="line">    //创建并行队列</div><div class="line">    // 参1:const char *label 队列名称</div><div class="line">    // 参2:dispatch_queue_attr_t attr 队列类型</div><div class="line">    queueConcurrent = dispatch_queue_create("concurrent.whenbar.com", DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">&#125;</div><div class="line">//1 获得主队列</div><div class="line">-(void)runqueueMain</div><div class="line">&#123;</div><div class="line">    // 获取主队列  在主队列中的任务都会在主线程中执行。</div><div class="line">    dispatch_queue_t queueMain = dispatch_get_main_queue();</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">//2. 创建串行队列</div><div class="line">-(void)runqueueSerial</div><div class="line">&#123;</div><div class="line">  </div><div class="line">    // GCD同步函数串行队列(立即执行，当前线程)</div><div class="line">    // 参1: dispatch_queue_t queue 队列</div><div class="line">    // 参2: 任务</div><div class="line">    dispatch_sync(queueSerial, ^&#123;</div><div class="line">        for (NSInteger i = 0; i &lt; 10; i++) &#123;</div><div class="line">            NSLog(@"~~~%ld %@",i, [NSThread currentThread]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    </div><div class="line">    // 异步函数串行队列 (另开线程，多个任务按顺序执行)</div><div class="line">    dispatch_async(queueSerial, ^&#123;</div><div class="line">        dispatch_async(queueSerial, ^&#123;</div><div class="line">            for (NSInteger i = 0; i &lt; 10; i++) &#123;</div><div class="line">                NSLog(@"~~~%ld %@",i, [NSThread currentThread]);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        dispatch_async(queueSerial, ^&#123;</div><div class="line">            for (NSInteger i = 0; i &lt; 10; i++) &#123;</div><div class="line">                NSLog(@"~~~%ld %@",i, [NSThread currentThread]);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        dispatch_async(queueSerial, ^&#123;</div><div class="line">            for (NSInteger i = 0; i &lt; 10; i++) &#123;</div><div class="line">                NSLog(@"~~~%ld %@",i, [NSThread currentThread]);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">//3. 创建并发队列</div><div class="line">-(void)runqueueConcurrent</div><div class="line">&#123;</div><div class="line">    </div><div class="line">    // 同步函数并行队列(立即执行，当前线程)</div><div class="line">    dispatch_sync(queueConcurrent, ^&#123;</div><div class="line">        for (NSInteger i = 0; i &lt; 10; i++) &#123;</div><div class="line">            NSLog(@"~~~%ld %@",i, [NSThread currentThread]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    // 异步函数并行队列 (另开线程，多个任务一起执行)</div><div class="line">    dispatch_async(queueConcurrent, ^&#123;</div><div class="line">        dispatch_async(queueConcurrent, ^&#123;</div><div class="line">            for (NSInteger i = 0; i &lt; 5; i++) &#123;</div><div class="line">                NSLog(@"~~~%ld %@",i, [NSThread currentThread]);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        dispatch_async(queueConcurrent, ^&#123;</div><div class="line">            for (NSInteger i = 0; i &lt; 6; i++) &#123;</div><div class="line">                NSLog(@"~~~%ld %@",i, [NSThread currentThread]);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        dispatch_async(queueConcurrent, ^&#123;</div><div class="line">            for (NSInteger i = 0; i &lt; 7; i++) &#123;</div><div class="line">                NSLog(@"~~~%ld %@",i, [NSThread currentThread]);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//4. 创建全局队列</div><div class="line">-(void)runqueueGlobal</div><div class="line">&#123;</div><div class="line">    // 获取全局队列 全局队列是并发队列</div><div class="line">    // 参1:队列的优先级</div><div class="line">    // 参2:0(以后可能用到的参数)//#define DISPATCH_QUEUE_PRIORITY_HIGH 2 // 高\</div><div class="line">    #define DISPATCH_QUEUE_PRIORITY_DEFAULT 0 // 默认（中）\</div><div class="line">    #define DISPATCH_QUEUE_PRIORITY_LOW (-2) // 低\</div><div class="line">    #define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN // 后台</div><div class="line">    dispatch_queue_t queueGlobal = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">// 主队列:(任何一个任务只要在主队列中，都会加入到主线程的队列中执行)</div></pre></td></tr></table></figure>
<p>TIPS: 注意<br>使用sync函数(同步函数)往当前串行队列中添加任务，会卡住当前的串行队列<br>解释：使用同步函数添加任务 A 到串行队列，说明要在当前串行队列立即执行任务 A ，任务 A 执行完后，才会执行任务 A 后面的代码。但当前队列是串行队列，也就是说任务 A 必须等到当前串行队列中正在执行的任务 B 完成之后才能执行，因此又必须先执行任务 A 中立即执行任务，又要必须等到任务 B 执行完以后才能执行下一个任务，所以就会卡死。你等我，我等你，谁也无法执行。</p>
<p>####GCD实现线程通信<br>小项目：下载图片</p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取图片的url</span></div><div class="line">NSURL *url = [NSURL URLWithString:@<span class="string">"http://7xjanq.com1.z0.glb.clouddn.com/6478.jpg"</span>];</div><div class="line"></div><div class="line"><span class="comment">// 开启线程下载图片</span></div><div class="line">dispatch_queue_t queue = dispatch_queue_create(<span class="string">"111"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">    NSData *data = [NSData dataWithContentsOfURL:url];</div><div class="line">    UIImage *image = [UIImage imageWithData:data];</div><div class="line"></div><div class="line">    <span class="comment">// 下载完成后返回主线程显示图片</span></div><div class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">        self.imageView.image = image;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>————————————————————————————————————————</p>
<p>GCD其他常用函数</p>
<p><img src="https://github.com/Natoto/ios-Multithread/blob/master/images/gcdmethod.png?raw=true" alt="image"><br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//----------------- 队列组 -----------------------------</span></div><div class="line"><span class="comment">//队列组可以将很多队列添加到一个组里，这样做的好处是，当这个组里所有的任务都执行完了，队列组会通过一个方法通知我们。下面是使用方法，这是一个很实用的功能。</span></div><div class="line">-(<span class="keyword">void</span>)rungroup</div><div class="line">&#123;</div><div class="line">    <span class="comment">//1.创建队列组</span></div><div class="line">    dispatch_group_t group=dispatch_group_create();</div><div class="line">    <span class="comment">//2.创建队列</span></div><div class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,<span class="number">0</span>);</div><div class="line">    <span class="comment">//3.多次使用队列组的方法执行任务, 只有异步方法</span></div><div class="line">    <span class="comment">//3.1.执行3次循环</span></div><div class="line">    dispatch_group_async(group,queue,^&#123;</div><div class="line">        <span class="keyword">for</span> (NSInteger i = <span class="number">0</span>; i&lt; <span class="number">3</span>; i++)&#123;</div><div class="line">            NSLog(@<span class="string">"group-01 - %@"</span>, [NSThread currentThread]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//3.2.主队列执行8次循环</span></div><div class="line">    dispatch_group_async(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="keyword">for</span> (NSInteger i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) &#123;</div><div class="line">            NSLog(@<span class="string">"group-02 - %@"</span>, [NSThread currentThread]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//3.3.执行5次循环</span></div><div class="line">    dispatch_group_async(group, queue, ^&#123;</div><div class="line">        <span class="keyword">for</span>(NSInteger i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</div><div class="line">            NSLog(@<span class="string">"group-03 - %@"</span>, [NSThread currentThread]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//4.都完成后会自动通知</span></div><div class="line">    dispatch_group_notify(group,dispatch_get_main_queue(),^&#123;</div><div class="line">        NSLog(@<span class="string">"完成 - %@"</span>, [NSThread currentThread]);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line">`dispatch_barrier<span class="string">` 栅栏</span></div><div class="line"></div><div class="line">`<span class="string">``</span>javascript</div><div class="line"><span class="comment">// 1.barrier : 在barrier前面的先执行，然后再执行barrier，然后再执行barrier后面的 barrier的queue不能是全局的并发队列</span></div><div class="line">dispatch_queue_t queue = dispatch_queue_create(<span class="string">"11"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>;  i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">        NSLog(@<span class="string">"%@--1"</span>, [NSThread currentThread]);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>;  i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">        NSLog(@<span class="string">"%@--2"</span>, [NSThread currentThread]);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_barrier_async(queue, ^&#123;</div><div class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>;  i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">        NSLog(@<span class="string">"%@--3"</span>, [NSThread currentThread]);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>;  i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">        NSLog(@<span class="string">"%@--4"</span>, [NSThread currentThread]);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//    dispatch_after 延迟执行</span></div><div class="line">    <span class="comment">// 延迟执行</span></div><div class="line">    <span class="comment">// 方法1</span></div><div class="line">    [self performSelector:@selector(run:) withObject:@<span class="string">"参数"</span> afterDelay:<span class="number">2.0</span>];</div><div class="line">    </div><div class="line">    <span class="comment">// 方法2</span></div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2.0</span> * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="keyword">for</span> (NSInteger i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">            NSLog(@<span class="string">"%@"</span>, [NSThread currentThread]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="comment">// 方法3</span></div><div class="line">    [NSTimer scheduledTimerWithTimeInterval:<span class="number">2.0</span> target:self selector:@selector(run:) userInfo:nil repeats:NO];</div><div class="line"></div><div class="line">dispatch_once 整个程序运行中执行一次</div><div class="line"><span class="comment">// 整个程序中只执行一次</span></div><div class="line"><span class="keyword">static</span> dispatch_once_t onceToken;</div><div class="line">dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">    <span class="comment">// 一次性代码</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>思考题：以下函数输出的结果是什么？<br><img src="https://github.com/Natoto/ios-Multithread/blob/master/images/dispatchafter.png?raw=true" alt="image"></p>
<p>以下的代码输出是什么呢<br><img src="https://github.com/Natoto/ios-Multithread/blob/master/images/dispatchafter2.png?raw=true" alt="image"></p>
<p>作用：实现某个类的单例对象</p>
<p>单例模式：在整个应用程序中，共享一份资源（这份资源只需要创建初始化1次）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line">//--------------单例模式--------------------</div><div class="line"></div><div class="line">#if __has_feature(objc_instancetype)</div><div class="line">#undef    AS_SINGLETON</div><div class="line">#define AS_SINGLETON( ... ) \</div><div class="line">- (instancetype)sharedInstance; \</div><div class="line">+ (instancetype)sharedInstance;</div><div class="line"></div><div class="line">#undef	DEF_SINGLETON</div><div class="line">#define DEF_SINGLETON \</div><div class="line">- (instancetype)sharedInstance \</div><div class="line">&#123; \</div><div class="line">return [[self class] sharedInstance]; \</div><div class="line">&#125; \</div><div class="line">+ (instancetype)sharedInstance \</div><div class="line">&#123; \</div><div class="line">static dispatch_once_t once; \</div><div class="line">static id __singleton__; \</div><div class="line">dispatch_once( &amp;once, ^&#123; __singleton__ = [[self alloc] init]; &#125; ); \</div><div class="line">return __singleton__; \</div><div class="line">&#125;</div><div class="line">#undef	DEF_SINGLETON</div><div class="line">#define DEF_SINGLETON( ... ) \</div><div class="line">- (instancetype)sharedInstance \</div><div class="line">&#123; \</div><div class="line">return [[self class] sharedInstance]; \</div><div class="line">&#125; \</div><div class="line">+ (instancetype)sharedInstance \</div><div class="line">&#123; \</div><div class="line">static dispatch_once_t once; \</div><div class="line">static id __singleton__; \</div><div class="line">dispatch_once( &amp;once, ^&#123; __singleton__ = [[self alloc] init]; &#125; ); \</div><div class="line">return __singleton__; \</div><div class="line">&#125;</div><div class="line"></div><div class="line">#else	// #if __has_feature(objc_instancetype)</div><div class="line">#undef	AS_SINGLETON</div><div class="line">#define AS_SINGLETON( __class ) \</div><div class="line">- (__class *)sharedInstance; \</div><div class="line">+ (__class *)sharedInstance;</div><div class="line"></div><div class="line">#undef	DEF_SINGLETON</div><div class="line">#define DEF_SINGLETON( __class ) \</div><div class="line">- (__class *)sharedInstance \</div><div class="line">&#123; \</div><div class="line">return [__class sharedInstance]; \</div><div class="line">&#125; \</div><div class="line">+ (__class *)sharedInstance \</div><div class="line">&#123; \</div><div class="line">static dispatch_once_t once; \</div><div class="line">static __class * __singleton__; \</div><div class="line">dispatch_once( &amp;once, ^&#123; __singleton__ = [[[self class] alloc] init]; &#125; ); \</div><div class="line">return __singleton__; \</div><div class="line">&#125;</div><div class="line"></div><div class="line">#endif	// #if __has_feature(objc_instancetype)</div><div class="line"></div><div class="line">#import "gcdfunViewController.h"</div><div class="line"></div><div class="line">#pragma mark - 单例模式👆 👇</div><div class="line">@interface Person:NSObject</div><div class="line">//+ (instancetype)shareInstance;</div><div class="line">AS_SINGLETON(Person)</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Person</div><div class="line">DEF_SINGLETON(Person)</div><div class="line"></div><div class="line">/*</div><div class="line">+ (instancetype)shareInstance</div><div class="line">&#123;</div><div class="line">    static id _person;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        _person = [[super alloc] init];</div><div class="line">    &#125;);</div><div class="line">    return _person;</div><div class="line">&#125;</div><div class="line">*/</div><div class="line">+ (instancetype)allocWithZone:(struct _NSZone *)zone</div><div class="line">&#123;</div><div class="line">    static id _person;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        _person = [super allocWithZone:zone];</div><div class="line">    &#125;);</div><div class="line">    return _person;</div><div class="line">&#125;</div><div class="line">- (id)copy</div><div class="line">&#123;</div><div class="line">    return [Person sharedInstance];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>开发中一般自定义成宏，比较方便，一行代码搞定。</p>
<p><code>dispatch_apply</code> 快速迭代</p>
<p>//示例小程序：将一个文件夹中的图片剪切到另一个文件夹<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)testdispatch_apply</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 将图片剪切到另一个文件夹里</span></div><div class="line">    NSString *<span class="keyword">from</span> = @<span class="string">"/Users/Ammar/Pictures/壁纸"</span>;</div><div class="line">    NSString *to = @<span class="string">"/Users/Ammar/Pictures/to"</span>;</div><div class="line">    NSFileManager *manager = [NSFileManager defaultManager];</div><div class="line">    NSArray *subPaths = [manager subpathsAtPath:<span class="keyword">from</span>];</div><div class="line">    </div><div class="line">    <span class="comment">// 快速迭代</span></div><div class="line">    dispatch_apply(subPaths.count, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^(size_t index) &#123;</div><div class="line">        NSLog(@<span class="string">"%@ - %zd"</span>, [NSThread currentThread], index);</div><div class="line">        NSString *subPath = subPaths[index];</div><div class="line">        NSString *fromPath = [<span class="keyword">from</span> stringByAppendingPathComponent:subPath];</div><div class="line">        NSString *toPath = [to stringByAppendingPathComponent:subPath];</div><div class="line">        </div><div class="line">        <span class="comment">// 剪切</span></div><div class="line">        [manager moveItemAtPath:fromPath toPath:toPath error:nil];</div><div class="line">        NSLog(@<span class="string">"%@---%zd"</span>, [NSThread currentThread], index);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//作用是把指定次数指定的block添加到queue中, 第一个参数是迭代次数，第二个是所在的队列，第三个是当前索引，dispatch_apply可以利用多核的优势，所以输出的index顺序不是一定的</span></div><div class="line">    dispatch_apply(<span class="number">10</span>, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^(size_t index) &#123;</div><div class="line">        NSLog(@<span class="string">"dispatch_apply %zd"</span>,index);</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">/*输出结果 无序的</span></div><div class="line">     2016-02-15 10:15:21.229 多线程[4346:48391] dispatch_apply 0</div><div class="line">     2016-02-15 10:15:21.229 多线程[4346:48784] dispatch_apply 1</div><div class="line">     2016-02-15 10:15:21.230 多线程[4346:48830] dispatch_apply 2</div><div class="line">     2016-02-15 10:15:21.230 多线程[4346:48391] dispatch_apply 4</div><div class="line">     2016-02-15 10:15:21.230 多线程[4346:48829] dispatch_apply 3</div><div class="line">     2016-02-15 10:15:21.231 多线程[4346:48391] dispatch_apply 6</div><div class="line">     2016-02-15 10:15:21.231 多线程[4346:48391] dispatch_apply 9</div><div class="line">     2016-02-15 10:15:21.230 多线程[4346:48784] dispatch_apply 5</div><div class="line">     2016-02-15 10:15:21.231 多线程[4346:48829] dispatch_apply 8</div><div class="line">     2016-02-15 10:15:21.231 多线程[4346:48830] dispatch_apply 7</div><div class="line">     */</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>dispatch_group</code> 队列组<br>示例小程序：需求下载图片1 下载图片2 将图片1和图片2合成新的图片</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建队列</span></div><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// 创建组</span></div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line"></div><div class="line"><span class="comment">// 用组队列下载图片1</span></div><div class="line">dispatch_group_async(group, queue, ^&#123;</div><div class="line">    NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:@<span class="string">"http://7xjanq.com1.z0.glb.clouddn.com/6478.jpg"</span>]];</div><div class="line">    self.image1 = [UIImage imageWithData:data];</div><div class="line">    NSLog(@<span class="string">"1%@"</span>, [NSThread currentThread]);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 用组队列下载图片2</span></div><div class="line">dispatch_group_async(group, queue, ^&#123;</div><div class="line">    NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:@<span class="string">"http://7xjanq.com1.z0.glb.clouddn.com/6478.jpg"</span>]];</div><div class="line">    self.image2 = [UIImage imageWithData:data];</div><div class="line">    NSLog(@<span class="string">"2%@"</span>, [NSThread currentThread]);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 将图片1和图片2合成一张图片</span></div><div class="line">dispatch_group_notify(group, queue, ^&#123;</div><div class="line">    CGFloat imageW = self.imageView.bounds.size.width;</div><div class="line">    CGFloat imageH = self.imageView.bounds.size.height;</div><div class="line"></div><div class="line">    <span class="comment">// 开启位图上下文</span></div><div class="line">    UIGraphicsBeginImageContext(self.imageView.bounds.size);</div><div class="line"></div><div class="line">    <span class="comment">// 画图</span></div><div class="line">    [self.image1 drawInRect:CGRectMake(<span class="number">0</span>, <span class="number">0</span>, imageW * <span class="number">0.5</span>, imageH)];</div><div class="line">    [self.image2 drawInRect:CGRectMake(imageW * <span class="number">0.5</span>, <span class="number">0</span>, imageW * <span class="number">0.5</span>, imageH)];</div><div class="line"></div><div class="line">    <span class="comment">// 将图片取出</span></div><div class="line">    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line"></div><div class="line">    <span class="comment">// 关闭图形上下文</span></div><div class="line">    UIGraphicsEndImageContext();</div><div class="line"></div><div class="line">    <span class="comment">// 在主线程上显示图片</span></div><div class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">        self.imageView.image = image;</div><div class="line">    &#125;);</div><div class="line">    NSLog(@<span class="string">"3%@"</span>, [NSThread currentThread]);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>####GCD定时器<br>GCD定时器不受Mode影响因此比NSTimer要准确</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">#pragma mark - 定时器</div><div class="line">//做定时器或倒计时</div><div class="line">-(IBAction)buttonTap:(id)sender</div><div class="line">&#123;</div><div class="line">    UIButton * button = (UIButton *)sender;</div><div class="line">    button.enabled = NO;</div><div class="line">    // 1.创建一个定时器源</div><div class="line">    </div><div class="line">    // 参1:类型定时器</div><div class="line">    // 参2:句柄</div><div class="line">    // 参3:mask传0</div><div class="line">    // 参4:队列  (注意:dispatch_source_t本质是OC对象，表示源)</div><div class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">    </div><div class="line">    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class="line">    </div><div class="line">    // 严谨起见，时间间隔需要用单位int64_t，做乘法以后单位就变了</div><div class="line">    // 下面这句代码表示回调函数时间间隔是多少</div><div class="line">    int64_t interval = (int64_t)(1.0 * NSEC_PER_SEC);</div><div class="line">    </div><div class="line">    // 如何设置开始时间 CGD给我们了一个设置时间的方法</div><div class="line">    // 参1:dispatch_time_t when 传一个时间， delta是增量</div><div class="line">    </div><div class="line">    dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)); // 从现在起0秒后开始</div><div class="line">    </div><div class="line">    // 参1:timer</div><div class="line">    // 参2:开始时间</div><div class="line">    // 参3:时间间隔</div><div class="line">    // 参4:传0 不需要   DISPATCH_TIME_NOW 表示现在 GCD 时间用 NS 表示</div><div class="line">    dispatch_source_set_timer(timer, start, interval, 0);</div><div class="line">    </div><div class="line">    __block int count = 60;</div><div class="line">    </div><div class="line">    // 3.设置回调(即每次间隔要做什么事情)</div><div class="line">    dispatch_source_set_event_handler(timer, ^&#123;</div><div class="line">        NSLog(@"----------------%@", [NSThread currentThread]);</div><div class="line">        // 如果希望做5次就停掉</div><div class="line">        count -- ;</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            if (count == 0) &#123;</div><div class="line">                dispatch_source_cancel(timer);</div><div class="line">                [button setTitle:@"点击倒计时" forState:UIControlStateNormal];</div><div class="line">                button.enabled = YES;</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">            &#123;</div><div class="line">                [button setTitle:[NSString stringWithFormat:@"%d",count] forState:UIControlStateNormal];</div><div class="line">                [button setTitle:[NSString stringWithFormat:@"%d",count] forState:UIControlStateDisabled];</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">    // 4.启动定时器  (恢复)</div><div class="line">    dispatch_resume(timer);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>gcd 还有一些其他的函数 下次再深入！</p>
<p>————————————————————————————————————————————————————————————————————————————————<br>讲完 GCD 就该讲讲 NSOperation，它是 GCD 的面向对象的封装，使用起来也更方便，</p>
<ul>
<li>NSOperation实现多线程</li>
<li><p>NSOperation是个抽象类，并不具备封装操作的能力，必须使用它的子类</p>
</li>
<li><p>NSInvocationOperation</p>
</li>
<li><p>NSBlockOperation<br>自定义子类继承NSOperation，实现内部相应的方法<br>使用 NSOperation 实现多线程的步骤：</p>
</li>
<li><p>创建任务 NSOperation 对象</p>
</li>
<li>创建 NSOperationQueue 队列</li>
<li>将任务 NSOperation 对象 add 到 NSOperationQueue 队列中去</li>
<li>NSInvocationOperation<br>代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];</div><div class="line"></div><div class="line">[op start];</div></pre></td></tr></table></figure>
<p>注意：默认情况下，调用了start方法后并不会开一条新的线程去执行，而是在当前线程同步执行操作，只有将 NSOperation 放到一个 NSOperationQueue 中，才会异步执行操作</p>
<ul>
<li>NSBlockOperation<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    // 在主线程</div><div class="line">      NSLog(@&quot;下载1------%@&quot;, [NSThread currentThread]);</div><div class="line">&#125;]; </div><div class="line">// 添加额外的任务(在子线程执行)，封装数大于1才会异步执行</div><div class="line">[op addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;下载2------%@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</li>
</ul>
<p>自定义Operation：需要实现- (void)main方法，需要做的事情放在mian方法中</p>
<ul>
<li>NSOperationQueue<br>使用<code>NSOperationQueue</code>创建队列：主队列和全局队列</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个其他队列(包括串行队列和并发队列) 放到这个队列中的NSOperation对象会自动放到子线程中执行</span></div><div class="line"></div><div class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</div><div class="line"></div><div class="line"><span class="comment">// 创建一个主队列，放到这个队列中的NSOperation对象会自动放到子线程中执行</span></div><div class="line">NSOperationQueue *mainQueue = [NSOperationQueue mainQueue];</div><div class="line"></div><div class="line"><span class="comment">// 表示并发数量：即同时执行任务的最大数。</span></div><div class="line">queue.maxConcurrentOperationCount = <span class="number">1</span>;</div><div class="line">队列的取消、暂停、恢复：</div><div class="line"><span class="comment">// NSOpertion的 - cancel 方法也可以停止单个操作</span></div><div class="line">- (<span class="keyword">void</span>)cancelAllOperations; </div><div class="line"><span class="comment">// YES代表暂停队列，NO代表恢复队列</span></div><div class="line">- (<span class="keyword">void</span>)setSuspended:(BOOL)b;</div><div class="line">添加依赖</div><div class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</div><div class="line">NSBlockOperation *block1 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@<span class="string">"download1 -------------- %@"</span>, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">NSBlockOperation *block2 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@<span class="string">"download2 -------------- %@"</span>, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">NSBlockOperation *block3 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@<span class="string">"download3 -------------- %@"</span>, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 添加依赖: block1 和 block2执行完后 再执行 block3  block3依赖于block1和block2</span></div><div class="line"></div><div class="line"><span class="comment">// 给block3添加依赖 让block3在block1和block2之后执行</span></div><div class="line">[block3 addDependency:block1];</div><div class="line">[block3 addDependency:block2];</div><div class="line"></div><div class="line">[queue addOperation:block1];</div><div class="line">[queue addOperation:block2];</div><div class="line">[queue addOperation:block3];</div><div class="line">注意：不能循环依赖，但可以跨队列依赖，不管NSOperation对象在哪个队列。只要是两个NSOperation对象就可以依赖</div><div class="line">线程间通信</div><div class="line">示例：下载图片</div><div class="line"></div><div class="line"><span class="comment">// 下载图片 operation实现线程间通信</span></div><div class="line">[[[NSOperationQueue alloc] init] addOperation:[NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    UIImage *image = [UIImage imageWithData:[NSData dataWithContentsOfURL:[NSURL URLWithString:@<span class="string">"http://7xjanq.com1.z0.glb.clouddn.com/6478.jpg"</span>]]];</div><div class="line"></div><div class="line">    <span class="comment">// 返回主线程</span></div><div class="line">    [[NSOperationQueue mainQueue] addOperation:[NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">        self.imageView.image = image;</div><div class="line">    &#125;]];</div><div class="line"></div><div class="line">&#125;]];</div></pre></td></tr></table></figure>
<p>示例：下载图片1和图片2 并合成图片<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)demo_combinenetworkimage</div><div class="line">&#123;</div><div class="line">    NSOperationQueue * queue = [[NSOperationQueue alloc] init];</div><div class="line">    </div><div class="line">    __block UIImage * image1;</div><div class="line">    NSBlockOperation * block1 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">        NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:@<span class="string">"http://img1.gtimg.com/15/1513/151394/15139471_980x1200_0.jpg"</span>]];</div><div class="line">        image1 = [UIImage imageWithData:data];</div><div class="line">        NSLog(@<span class="string">"下载图片1%@"</span>, [NSThread currentThread]);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    __block UIImage * image2;</div><div class="line">    NSBlockOperation * block2 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">        NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:@<span class="string">"http://img1.gtimg.com/15/1513/151311/15131165_980x1200_0.png"</span>]];</div><div class="line">        image2 = [UIImage imageWithData:data];</div><div class="line">        NSLog(@<span class="string">"下载图片2%@"</span>, [NSThread currentThread]);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    </div><div class="line">    NSBlockOperation * block3 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">       </div><div class="line">        CGFloat imageW = self.imageView.bounds.size.width;</div><div class="line">        CGFloat imageH = self.imageView.bounds.size.height;</div><div class="line">        </div><div class="line">        <span class="comment">// 开启位图上下文</span></div><div class="line">        UIGraphicsBeginImageContext(self.imageView.bounds.size);</div><div class="line">        </div><div class="line">        <span class="comment">// 画图</span></div><div class="line">        [image1 drawInRect:CGRectMake(<span class="number">0</span>, <span class="number">0</span>, imageW * <span class="number">0.5</span>, imageH)];</div><div class="line">        [image2 drawInRect:CGRectMake(imageW * <span class="number">0.5</span>, <span class="number">0</span>, imageW * <span class="number">0.5</span>, imageH)];</div><div class="line">        </div><div class="line">        <span class="comment">// 将图片取出</span></div><div class="line">        UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">        </div><div class="line">        <span class="comment">// 关闭图形上下文</span></div><div class="line">        UIGraphicsEndImageContext();</div><div class="line">        </div><div class="line">        <span class="comment">// 在主线程上显示图片</span></div><div class="line">        [[NSOperationQueue mainQueue] addOperation:[NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">            NSLog(@<span class="string">"合成图片 %@"</span>, [NSThread currentThread]);</div><div class="line">            self.imageView.image = image;</div><div class="line">        &#125;]];</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [block3 addDependency:block1];</div><div class="line">    [block3 addDependency:block2];</div><div class="line">    </div><div class="line">    [queue addOperation:block1];</div><div class="line">    [queue addOperation:block2];</div><div class="line">    [queue addOperation:block3];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><p>应用：SDWebImage 框架的底层主要功能实现就是基于多线程，使用多线程，我们可以实现小图片的多图片下载。这里的逻辑其实是比较复杂的<br>实现小图片的多图片下载思路：</p>
<p>TIPS: 以上就是一些主要方法, 下面还有一些常用方法需要大家注意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">NSOperation</div><div class="line">BOOL executing; //判断任务是否正在执行</div><div class="line">BOOL finished; //判断任务是否完成</div><div class="line">void (^completionBlock)(void); //用来设置完成后需要执行的操作</div><div class="line"></div><div class="line">- (void)cancel; //取消任务</div><div class="line">- (void)waitUntilFinished; //阻塞当前线程直到此任务执行完毕</div><div class="line">NSOperationQueue </div><div class="line"></div><div class="line">NSUInteger operationCount; //获取队列的任务数</div><div class="line">- (void)cancelAllOperations; //取消队列中所有的任务</div><div class="line">- (void)waitUntilAllOperationsAreFinished; //阻塞当前线程直到此队列中的所有任务执行完毕</div><div class="line">[queue setSuspended:YES]; // 暂停queue</div><div class="line">[queue setSuspended:NO]; // 继续queue</div></pre></td></tr></table></figure>
</li>
</ul>
<p>###线程同步</p>
<p>所谓线程同步就是为了防止多个线程抢夺同一个资源造成的数据安全问题，所采取的一种措施。当然也有很多实现方法，请往下看：</p>
<p>互斥锁 ：给需要同步的代码块加一个互斥锁，就可以保证每次只有一个线程访问此代码块。<br> <code>@synchronized</code>(self) {<br>    //需要执行的代码块<br>}</p>
<ul>
<li>原创博客地址 <a href="http://www.jianshu.com/p/b91b42235285" target="_blank" rel="external">http://www.jianshu.com/p/b91b42235285</a> </li>
<li>第一次认真写一篇博文希望大家多多批评指正</li>
<li>如有问题欢迎大家关注我的微信 ExtremeFruit</li>
<li>如果有兴趣欢迎下载<a href="https://github.com/Natoto/ios-Multithread" target="_blank" rel="external">多线程DEMO</a></li>
<li>喜欢就点个赞呗！</li>
</ul>
<p><img src="http://mp.weixin.qq.com/mp/qrcode?scene=10000004&amp;size=102&amp;__biz=MzA3ODQyNDM0Mg==" alt="ExtremeFruit"></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/iOS多线程的四种技术方案/" class="archive-article-date">
  	<time datetime="2016-11-22T08:17:17.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-22</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
  
    <a href="/2016/11/GitHub Pages 绑定来自阿里云的域名/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">GitHub Pages 绑定来自阿里云的域名</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>




<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
	    <a class="jiathis_button_twitter"></a>
	    <a class="jiathis_button_plus"></a> 
	    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="//v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="iOS多线程的四种技术方案" data-title="" data-url="http://natoto.github.io/2016/11/iOS多线程的四种技术方案/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>





      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 nonato
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/github-domain-cname/" style="font-size: 10px;">github,domain,cname</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/技术/" style="font-size: 15px;">技术</a> <a href="/tags/机器学习/" style="font-size: 15px;">机器学习</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jianshu.com/users/cc52a4f9fcc5/latest_articles">简书</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://weibo.com/huangbo0913">微博</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/nonato">博客园</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://github.com/natoto">github</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">&lt;br&gt;长方体混凝土瞬间移动工程师&lt;br&gt;&lt;br&gt;专注移动开发，&lt;br&gt;略懂前端，&lt;br&gt;&lt;br&gt;略懂脚本，&lt;br&gt;略懂机器学习&lt;br&gt;&lt;br&gt;感谢大家光临</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>